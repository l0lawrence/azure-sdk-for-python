# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union, get_type_hints, get_origin, get_args
from typing_extensions import TypedDict, Required, NotRequired, is_typeddict
from azure.core import CaseInsensitiveEnumMeta

from .models import ResourceType, ResourceTypeParameters


# --------------------------------------------------------------------------
# Runtime TypedDict validation helpers
# --------------------------------------------------------------------------

def _parse_datetime_string(value: Any) -> Optional[datetime.datetime]:
    """Parse datetime from ISO string."""
    if value is None or isinstance(value, datetime.datetime):
        return value
    if isinstance(value, str):
        try:
            return datetime.datetime.fromisoformat(value.replace("Z", "+00:00"))
        except Exception:
            return value
    return value


def _parse_enum_value(value: Any, enum_cls: type) -> Any:
    """Parse enum value from string."""
    if value is None or isinstance(value, enum_cls):
        return value
    if isinstance(value, str) and issubclass(enum_cls, Enum):
        try:
            return enum_cls(value)
        except (ValueError, KeyError):
            try:
                return enum_cls[value]
            except (ValueError, KeyError):
                return value
    return value


def _validate_typeddict_field(value: Any, field_type: type) -> Any:
    """Validate and transform a field value based on its type hint."""
    origin = get_origin(field_type)
    args = get_args(field_type)
    
    # Handle Optional[T] -> Union[T, None]
    if origin is Union:
        # Check if this is Optional (Union with None)
        if len(args) == 2 and type(None) in args:
            if value is None:
                return None
            # Get the non-None type
            inner_type = next(arg for arg in args if arg is not type(None))
            return _validate_typeddict_field(value, inner_type)
        else:
            # Regular Union - try each type
            for arg in args:
                try:
                    return _validate_typeddict_field(value, arg)
                except Exception:
                    continue
            return value
    
    # Handle List[T]
    elif origin is list or origin is List:
        if not isinstance(value, list):
            return value
        if args:
            item_type = args[0]
            return [_validate_typeddict_field(item, item_type) for item in value]
        return value
    
    # Handle Dict[K, V]
    elif origin is dict or origin is Dict:
        if not isinstance(value, dict):
            return value
        if len(args) >= 2:
            key_type, value_type = args[0], args[1]
            return {
                _validate_typeddict_field(k, key_type): _validate_typeddict_field(v, value_type)
                for k, v in value.items()
            }
        return value
    
    # Handle TypedDict
    elif is_typeddict(field_type):
        return _create_runtime_typeddict_instance(value, field_type)
    
    # Handle Enum
    elif isinstance(field_type, type) and issubclass(field_type, Enum):
        return _parse_enum_value(value, field_type)
    
    # Handle datetime
    elif field_type is datetime.datetime:
        return _parse_datetime_string(value)
    
    # Handle basic types
    elif field_type in (str, int, float, bool):
        if value is None:
            return None
        try:
            return field_type(value)
        except (ValueError, TypeError):
            return value
    
    # Return as-is for unknown types
    return value


def _validate_typeddict_properties(data: Any, typeddict_class: type) -> Dict[str, Any]:
    """Validate and transform data according to a TypedDict schema."""
    if not isinstance(data, dict):
        data = data or {}
    
    hints = get_type_hints(typeddict_class, include_extras=True)
    result = {}
    
    for field_name, field_type in hints.items():
        if field_name in data:
            result[field_name] = _validate_typeddict_field(data[field_name], field_type)
        else:
            # Check if field is required (not Optional and not NotRequired)
            origin = get_origin(field_type)
            if origin is Union:
                args = get_args(field_type)
                if len(args) == 2 and type(None) in args:
                    # Optional field
                    result[field_name] = None
            # For NotRequired fields, we don't set them if missing
    
    # Include any extra fields that aren't in the TypedDict
    for key, value in data.items():
        if key not in hints:
            result[key] = value
    
    return result


def _create_runtime_typeddict_instance(data: Any, typeddict_class: type):
    """Create a runtime instance that behaves like the TypedDict class."""
    validated_data = _validate_typeddict_properties(data, typeddict_class)
    
    # Create a new class that extends dict but identifies as the TypedDict
    class RuntimeTypedDict(dict):
        def __class_getitem__(cls, item):
            return typeddict_class
        
        def __repr__(self):
            return f"{typeddict_class.__name__}({super().__repr__()})"
    
    # Set the class name and module to match the TypedDict
    RuntimeTypedDict.__name__ = typeddict_class.__name__
    RuntimeTypedDict.__qualname__ = typeddict_class.__qualname__
    RuntimeTypedDict.__module__ = typeddict_class.__module__
    
    # Create instance and populate with validated data
    instance = RuntimeTypedDict(validated_data)
    
    # Make type() return the TypedDict class
    instance.__class__ = type(typeddict_class.__name__, (dict,), {
        '__module__': typeddict_class.__module__,
        '__qualname__': typeddict_class.__qualname__,
        '__repr__': lambda self: f"{typeddict_class.__name__}({dict.__repr__(self)})"
    })
    
    return instance


class AccountImmutabilityPolicyState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the
    policy, Unlocked state allows increase and decrease of immutability retention time and also
    allows toggling allowProtectedAppendWrites property, Locked state only allows the increase of
    the immutability retention time. A policy can only be created in a Disabled or Unlocked state
    and can be toggled between the two states. Only a policy in an Unlocked state can transition to
    a Locked state which cannot be reverted.
    """

    UNLOCKED = "Unlocked"
    LOCKED = "Locked"
    DISABLED = "Disabled"

class ImmutabilityPolicyProperties(TypedDict):
    """Properties of an Immutability Policy."""
    immutability_period_since_creation_in_days: Optional[int]
    state: Optional[Union[str,AccountImmutabilityPolicyState]]
    allow_protected_append_writes: Optional[bool]

class TagProperty(TypedDict):
    """Tag property of a Legal Hold."""
    tag: Optional[str]
    timestamp: Optional[datetime.datetime]
    object_identifier: Optional[str]
    tenant_id: Optional[str]
    upn: Optional[str]

class ProtectedAppendWritesHistory(TypedDict):
    """Protected append writes history."""
    allow_protected_append_writes_all: Optional[bool]
    timestamp: Optional[datetime.datetime]

class LegalHoldProperties(TypedDict):
    """Properties of a Legal Hold."""
    has_legal_hold: Optional[bool]
    tags: Optional[List[TagProperty]]
    protected_append_writes_history: Optional[ProtectedAppendWritesHistory]


class MigrationState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """This property denotes the container level immutability to object level immutability migration
    state.
    """

    IN_PROGRESS = "InProgress"
    COMPLETED = "Completed"

class ImmutableStorageWithVersioning(TypedDict):
    """Immutable storage with versioning properties."""
    enabled: Optional[bool]
    time_stamp: Optional[datetime.datetime]
    migration_state: Optional[Union[str, MigrationState]]


class BlobContainerProperties(TypedDict):
    """Properties of a Blob Container resource."""
    public_access: Optional[str]
    last_modified_time: Optional[str]
    etag: Optional[str]
    version: Optional[str]
    deleted: Optional[bool]
    deleted_time: Optional[str]
    remaining_retention_days: Optional[int]
    default_encryption_scope: Optional[str]
    deny_encryption_scope_override: Optional[bool]
    lease_status: Optional[str]
    lease_state: Optional[str]
    lease_duration: Optional[str]
    metadata: Optional[Dict[str, str]]
    immutability_policy: Optional[ImmutabilityPolicyProperties]
    legal_hold: Optional[LegalHoldProperties]
    has_legal_hold: Optional[bool]
    has_immutability_policy: Optional[bool]
    immutable_storage_with_versioning: Optional[ImmutableStorageWithVersioning]
    enable_nfs_v3_root_squash: Optional[bool]
    enable_nfs_v3_all_squash: Optional[bool]

class BlobContainerParameters(ResourceTypeParameters):
    """Parameters for BlobContainer resource."""
    storage_account_name: Required[str]
    container_name: Required[str]

class BlobContainer(ResourceType[BlobContainerProperties]):

    """A Blob Container resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param resource_group_name: The name of the resource group. Required.
    :type resource_group_name: str
    :param storage_account_name: The name of the storage account. Required.
    :type storage_account_name: str
    :param container_name: The name of the blob container. Required.
    :type container_name: str
    :keyword api_version: The API version used to create the resource.
    :paramtype api_version: str
    :keyword properties: Properties of a Blob Container resource.
    :paramtype properties: ~azure.mgmt.crud.models.BlobContainerProperties
    """

    # URL template for this resource type
    _url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    def build_instance_path_arguments(self, subscription_id: str) -> Dict[str, str]:
        """Build path arguments from instance attributes.

        :param subscription_id: The Azure subscription ID
        :type subscription_id: str
        :return: Dictionary of path arguments for URL construction
        :rtype: Dict[str, str]
        """
        return {
            "subscriptionId": subscription_id,
            "resourceGroupName": self.resource_group_name,
            "storageAccountName": self.storage_account_name,
            "containerName": self.container_name,
        }

    _validation = {
        "id": {"readonly": True},
        "name": {"readonly": True},
        "type": {"readonly": True},
        "etag": {"readonly": True},
        "last_modified_time": {"readonly": True},
        "deleted": {"readonly": True},
        "deleted_time": {"readonly": True},
        "remaining_retention_days": {"readonly": True},
        "lease_status": {"readonly": True},
        "lease_state": {"readonly": True},
        "has_legal_hold": {"readonly": True},
        "has_immutability_policy": {"readonly": True},
    }

    @classmethod
    def from_response(cls, data_dict: Dict[str, Any], **kwargs) -> 'BlobContainer':
        """Create BlobContainer instance from API response data and path arguments.

        :param data_dict: The response data dictionary from Azure API
        :type data_dict: Dict[str, Any]
        :keyword path_arguments: URL path arguments used in the API call
        :paramtype path_arguments: Dict[str, str]
        :return: Created BlobContainer instance
        :rtype: BlobContainer
        """
        # Create runtime TypedDict instance with validation
        properties = _create_runtime_typeddict_instance(data_dict.get('properties', {}), BlobContainerProperties)

        # Extract info from path_arguments if provided, otherwise fallback to kwargs or request_model
        path_arguments = kwargs.get('path_arguments', {})
        
        if path_arguments:
            # Use info from path arguments
            resource_group_name = path_arguments.get('resourceGroupName', 'unknown')
            storage_account_name = path_arguments.get('storageAccountName', 'unknown')
            container_name = path_arguments.get('containerName', 'unknown')
        else:
            # Final fallback to kwargs
            resource_group_name = kwargs.get('resource_group_name', 'unknown')
            storage_account_name = kwargs.get('storage_account_name', 'unknown')
            container_name = kwargs.get('container_name', 'unknown')
        
        api_version = kwargs.get('api_version', '2025-06-01')

        # Create instance with BlobContainer-specific constructor parameters
        instance = cls(
            resource_group_name=resource_group_name,
            storage_account_name=storage_account_name,
            container_name=container_name,
            api_version=api_version,
            properties=properties
        )

        # Set response data attributes
        instance.id = data_dict.get('id')
        instance.name = data_dict.get('name')
        instance.type = data_dict.get('type')

        return instance

    def __init__(self, resource_group_name: str, storage_account_name: str, container_name: str, **kwargs) -> None:
        super().__init__()
        self.resource_group_name = resource_group_name
        self.storage_account_name = storage_account_name
        self.container_name = container_name
        self.api_version: str = kwargs.get("api_version", "2025-06-01")
        self.properties: Optional[BlobContainerProperties] = kwargs.get("properties", None)

class CreatedByType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The type of identity that created the resource."""

    USER = "User"
    APPLICATION = "Application"
    MANAGED_IDENTITY = "ManagedIdentity"
    KEY = "Key"

class SystemData(TypedDict):
    created_by: Optional[str]
    created_by_type: Optional[Union[str, CreatedByType]]
    created_at: Optional[datetime.datetime]
    last_modified_by: Optional[str]
    last_modified_by_type: Optional[Union[str, CreatedByType]]
    last_modified_at: Optional[datetime.datetime]


class InventoryRuleType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The valid value is Inventory."""

    INVENTORY = "Inventory"

class Format(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """This is a required field, it specifies the format for the inventory files."""

    CSV = "Csv"
    PARQUET = "Parquet"

class Schedule(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """This is a required field. This field is used to schedule an inventory formation."""

    DAILY = "Daily"
    WEEKLY = "Weekly"

class ObjectType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """This is a required field. This field specifies the scope of the inventory created either at the
    blob or container level.
    """

    BLOB = "Blob"
    CONTAINER = "Container"

class BlobInventoryCreationTime(TypedDict):
    last_n_days: Optional[int]

class BlobInventoryPolicyFilter(TypedDict):
    prefix_match: Optional[List[str]]
    exclude_prefix: Optional[List[str]]
    blob_types: Optional[List[str]]
    include_blob_versions: Optional[bool]
    include_snapshots: Optional[bool]
    include_deleted: Optional[bool]
    creation_time: Optional[BlobInventoryCreationTime]

class BlobInventoryPolicyDefinition(TypedDict):
    format: Union[str, Format]
    schedule: Union[str, Schedule]
    object_type: Union[str, ObjectType]
    schema_fields: List[str]
    filters: Optional[BlobInventoryPolicyFilter]


class BlobInventoryPolicyRule(TypedDict):
    enabled: bool
    name: str
    destination: str        
    definition: BlobInventoryPolicyDefinition

class BlobInventoryPolicySchema(TypedDict):
    enabled: bool
    destination: NotRequired[str]
    type: Union[str, InventoryRuleType]
    rules: List[BlobInventoryPolicyRule]

class BlobInventoryPolicyProperties(TypedDict):
    """Properties of a Blob Inventory Policy resource."""
    system_data: NotRequired[SystemData]
    last_modified_time: NotRequired[Optional[datetime.datetime]]
    policy: Optional[BlobInventoryPolicySchema]


class BlobInventoryPolicy(ResourceType[BlobInventoryPolicyProperties]):

    """A Blob Inventory Policy resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param resource_group_name: The name of the resource group. Required.
    :type resource_group_name: str
    :param storage_account_name: The name of the storage account. Required.
    :type storage_account_name: str
    :keyword api_version: The API version used to create the resource.
    :paramtype api_version: str
    :keyword properties: Properties of a Blob Inventory Policy resource.
    :paramtype properties: ~azure.mgmt.crud.models.BlobInventoryPolicyProperties
    """

    # URL template for this resource type
    _url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{storageAccountName}/inventoryPolicies/{blobInventoryPolicyName}"
    )

    def build_instance_path_arguments(self, subscription_id: str) -> Dict[str, str]:
            """Build path arguments from instance attributes.

            :param subscription_id: The Azure subscription ID
            :type subscription_id: str
            :return: Dictionary of path arguments for URL construction
            :rtype: Dict[str, str]
            """
            return {
                "subscriptionId": subscription_id,
                "resourceGroupName": self.resource_group_name,
                "storageAccountName": self.storage_account_name,
                "blobInventoryPolicyName": self.blob_inventory_policy_name,
            }
    
    @classmethod
    def from_response(cls, data_dict: Dict[str, Any], **kwargs) -> 'BlobInventoryPolicy':
        """Create BlobInventoryPolicy instance from API response data and path arguments.

        :param data_dict: The response data dictionary from Azure API
        :type data_dict: Dict[str, Any]
        :keyword path_arguments: URL path arguments used in the API call
        :paramtype path_arguments: Dict[str, str]
        :return: Created BlobInventoryPolicy instance
        :rtype: BlobInventoryPolicy
        """
        # Create runtime TypedDict instance with validation
        properties = _create_runtime_typeddict_instance(data_dict.get('properties', {}), BlobInventoryPolicyProperties)

        # Extract info from path_arguments if provided, otherwise fallback to kwargs or request_model
        path_arguments = kwargs.get('path_arguments', {})
        
        if path_arguments:
            # Use info from path arguments
            resource_group_name = path_arguments.get('resourceGroupName', 'unknown')
            storage_account_name = path_arguments.get('storageAccountName', 'unknown')
            blob_inventory_policy_name = path_arguments.get('blobInventoryPolicyName', 'unknown')
        else:
            resource_group_name = kwargs.get('resource_group_name', 'unknown')
            storage_account_name = kwargs.get('storage_account_name', 'unknown')
            blob_inventory_policy_name = kwargs.get('blob_inventory_policy_name', 'unknown')
    
        api_version = kwargs.get('api_version', '2025-06-01')

        # Create instance with BlobInventoryPolicy-specific constructor parameters
        instance = cls(
            resource_group_name=resource_group_name,
            storage_account_name=storage_account_name,
            blob_inventory_policy_name=blob_inventory_policy_name,
            api_version=api_version,
            properties=properties
        )

        # Set response data attributes
        instance.id = data_dict.get('id')
        instance.name = data_dict.get('name')
        instance.type = data_dict.get('type')

        return instance
    
    def __init__(self, resource_group_name: str, storage_account_name: str, blob_inventory_policy_name: str, **kwargs) -> None:
        super().__init__()
        self.resource_group_name = resource_group_name
        self.storage_account_name = storage_account_name
        self.blob_inventory_policy_name = blob_inventory_policy_name
        self.api_version: str = kwargs.get("api_version", "2025-06-01")
        self.properties: Optional[BlobInventoryPolicyProperties] = kwargs.get("properties", None)