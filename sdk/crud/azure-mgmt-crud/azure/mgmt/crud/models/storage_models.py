# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import re
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from typing_extensions import TypedDict, NotRequired
from azure.core import CaseInsensitiveEnumMeta

from .models import ResourceType, ResourceId


class StorageAccountSkuName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The SKU name for the storage account."""
    STANDARD_LRS = "Standard_LRS"
    STANDARD_GRS = "Standard_GRS"
    STANDARD_RAGRS = "Standard_RAGRS"
    STANDARD_ZRS = "Standard_ZRS"
    PREMIUM_LRS = "Premium_LRS"
    PREMIUM_ZRS = "Premium_ZRS"
    STANDARD_GZRS = "Standard_GZRS"
    STANDARD_RAGZRS = "Standard_RAGZRS"


class StorageAccountKind(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The kind of storage account."""
    STORAGE = "Storage"
    STORAGE_V2 = "StorageV2"
    BLOB_STORAGE = "BlobStorage"
    FILE_STORAGE = "FileStorage"
    BLOCK_BLOB_STORAGE = "BlockBlobStorage"


class AccessTier(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The access tier for the storage account."""
    HOT = "Hot"
    COOL = "Cool"


class ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The provisioning state of the storage account."""
    CREATING = "Creating"
    RESOLVING_DNS = "ResolvingDNS"
    SUCCEEDED = "Succeeded"


class StorageAccountSku(TypedDict):
    """SKU of the storage account."""
    name: Union[str, StorageAccountSkuName]
    tier: NotRequired[Optional[str]]


class StorageAccountProperties(TypedDict):
    """Properties of a Storage Account resource."""
    provisioningState: NotRequired[Optional[Union[str, ProvisioningState]]]
    primaryEndpoints: NotRequired[Optional[Dict[str, str]]]
    primaryLocation: NotRequired[Optional[str]]
    statusOfPrimary: NotRequired[Optional[str]]
    secondaryLocation: NotRequired[Optional[str]]
    statusOfSecondary: NotRequired[Optional[str]]
    creationTime: NotRequired[Optional[str]]
    customDomain: NotRequired[Optional[Dict[str, Any]]]
    encryption: NotRequired[Optional[Dict[str, Any]]]
    accessTier: NotRequired[Optional[Union[str, AccessTier]]]
    networkAcls: NotRequired[Optional[Dict[str, Any]]]
    isHnsEnabled: NotRequired[Optional[bool]]
    supportsHttpsTrafficOnly: NotRequired[Optional[bool]]
    minimumTlsVersion: NotRequired[Optional[str]]
    allowBlobPublicAccess: NotRequired[Optional[bool]]
    allowSharedKeyAccess: NotRequired[Optional[bool]]


class StorageAccountPathParams(TypedDict):
    """URL parameters required to address a storage account."""
    resourceGroupName: str
    accountName: str


class AccountImmutabilityPolicyState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the
    policy, Unlocked state allows increase and decrease of immutability retention time and also
    allows toggling allowProtectedAppendWrites property, Locked state only allows the increase of
    the immutability retention time. A policy can only be created in a Disabled or Unlocked state
    and can be toggled between the two states. Only a policy in an Unlocked state can transition to
    a Locked state which cannot be reverted.
    """

    UNLOCKED = "Unlocked"
    LOCKED = "Locked"
    DISABLED = "Disabled"

class ImmutabilityPolicyProperties(TypedDict):
    """Properties of an Immutability Policy."""
    immutabilityPeriodSinceCreationInDays: Optional[int]
    state: Optional[Union[str,AccountImmutabilityPolicyState]]
    allowProtectedAppendWrites: Optional[bool]

class TagProperty(TypedDict):
    """Tag property of a Legal Hold."""
    tag: Optional[str]
    timestamp: Optional[str]
    objectIdentifier: Optional[str]
    tenantId: Optional[str]
    upn: Optional[str]

class ProtectedAppendWritesHistory(TypedDict):
    """Protected append writes history."""
    allowProtectedAppendWritesAll: Optional[bool]
    timestamp: Optional[str]

class LegalHoldProperties(TypedDict):
    """Properties of a Legal Hold."""
    hasLegalHold: Optional[bool]
    tags: Optional[List[TagProperty]]
    protectedAppendWritesHistory: Optional[ProtectedAppendWritesHistory]

class MigrationState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """This property denotes the container level immutability to object level immutability migration
    state.
    """

    IN_PROGRESS = "InProgress"
    COMPLETED = "Completed"

class ImmutableStorageWithVersioning(TypedDict):
    """Immutable storage with versioning properties."""
    enabled: Optional[bool]
    timeStamp: Optional[str]
    migrationState: Optional[Union[str, MigrationState]]


class BlobContainerProperties(TypedDict):
    """Properties of a Blob Container resource."""
    publicAccess: NotRequired[Optional[str]]
    lastModifiedTime: NotRequired[Optional[str]]
    etag: NotRequired[Optional[str]]
    version: NotRequired[Optional[str]]
    deleted: NotRequired[Optional[bool]]
    deletedTime: NotRequired[Optional[str]]
    remainingRetentionDays: NotRequired[Optional[int]]
    defaultEncryptionScope: NotRequired[Optional[str]]
    denyEncryptionScopeOverride: NotRequired[Optional[bool]]
    leaseStatus: NotRequired[Optional[str]]
    leaseState: NotRequired[Optional[str]]
    leaseDuration: NotRequired[Optional[str]]
    metadata: NotRequired[Optional[Dict[str, str]]]
    immutabilityPolicy: NotRequired[Optional[ImmutabilityPolicyProperties]]
    legalHold: NotRequired[Optional[LegalHoldProperties]]
    hasLegalHold: NotRequired[Optional[bool]]
    hasImmutabilityPolicy: NotRequired[Optional[bool]]
    immutableStorageWithVersioning: NotRequired[Optional[ImmutableStorageWithVersioning]]
    enableNfsV3RootSquash: NotRequired[Optional[bool]]
    enableNfsV3AllSquash: NotRequired[Optional[bool]]


class BlobContainerPathParams(TypedDict):
    """URL parameters required to address a blob container."""

    resourceGroupName: str
    storageAccountName: str
    containerName: str


class BlobContainerResourceId(ResourceId):
    """Resource identity for Blob Container resources.
    
    Encapsulates the identity information required to address a specific
    blob container instance within Azure Storage.
    """
    
    # URL templates for blob container operations
    _read_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    _create_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    _delete_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    _update_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    _list_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers"
    )
    
    # Action URL templates (POST operations)
    _action_url_templates = {
        "setLegalHold": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
            "blobServices/default/containers/{containerName}/setLegalHold"
        ),
        "clearLegalHold": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
            "blobServices/default/containers/{containerName}/clearLegalHold"
        ),
        "lease": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
            "blobServices/default/containers/{containerName}/lease"
        ),
        "migrate": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
            "blobServices/default/containers/{containerName}/migrate"
        ),
    }
    
    def __init__(
        self,
        *,
        resource_group_name: str,
        storage_account_name: str,
        container_name: str,
    ) -> None:
        """Initialize a BlobContainerResourceId.
        
        :param resource_group_name: Name of the resource group
        :type resource_group_name: str
        :param storage_account_name: Name of the storage account
        :type storage_account_name: str
        :param container_name: Name of the container
        :type container_name: str
        """
        self.resource_group_name = resource_group_name
        self.storage_account_name = storage_account_name
        self.container_name = container_name
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to BlobContainerPathParams TypedDict.
        
        :return: PathParams dictionary
        :rtype: Dict[str, Any]
        """
        return {
            "resourceGroupName": self.resource_group_name,
            "storageAccountName": self.storage_account_name,
            "containerName": self.container_name,
        }
    
    @classmethod
    def from_dict(cls, params: Dict[str, Any]) -> "BlobContainerResourceId":
        """Create from BlobContainerPathParams TypedDict.
        
        :param params: URL parameters dictionary
        :type params: Dict[str, Any]
        :return: New BlobContainerResourceId instance
        :rtype: BlobContainerResourceId
        """
        return cls(
            resource_group_name=params["resourceGroupName"],
            storage_account_name=params["storageAccountName"],
            container_name=params["containerName"],
        )
    
    @classmethod
    def from_resource_id(cls, resource_id: str) -> "BlobContainerResourceId":
        """Parse an ARM resource ID string for a blob container.
        
        Expected format:
        /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}
        
        :param resource_id: Full ARM resource ID string
        :type resource_id: str
        :return: New BlobContainerResourceId instance
        :rtype: BlobContainerResourceId
        :raises ValueError: If the resource ID format is invalid
        """
        pattern = (
            r"^/subscriptions/[^/]+/resourceGroups/(?P<resourceGroupName>[^/]+)/"
            r"providers/Microsoft\.Storage/storageAccounts/(?P<storageAccountName>[^/]+)/"
            r"blobServices/default/containers/(?P<containerName>[^/]+)$"
        )
        
        match = re.match(pattern, resource_id, re.IGNORECASE)
        if not match:
            raise ValueError(
                f"Invalid blob container resource ID format: {resource_id}. "
                f"Expected format: /subscriptions/{{subscriptionId}}/resourceGroups/{{resourceGroupName}}/"
                f"providers/Microsoft.Storage/storageAccounts/{{accountName}}/blobServices/default/"
                f"containers/{{containerName}}"
            )
        
        return cls(
            resource_group_name=match.group("resourceGroupName"),
            storage_account_name=match.group("storageAccountName"),
            container_name=match.group("containerName"),
        )
    
    def build_path_arguments(self, subscription_id: str) -> Dict[str, Any]:
        """Build path arguments dictionary for URL formatting.
        
        :param subscription_id: Azure subscription ID
        :type subscription_id: str
        :return: Dictionary of path arguments
        :rtype: Dict[str, Any]
        """
        return {
            "subscriptionId": subscription_id,
            "resourceGroupName": self.resource_group_name,
            "storageAccountName": self.storage_account_name,
            "containerName": self.container_name,
        }
    
    @classmethod
    def get_operation_url(
        cls,
        operation: str,
        subscription_id: str,
        resource_id: "ResourceId",
    ) -> str:
        """Get the URL template for the given operation.
        
        :param operation: Operation name
        :type operation: str
        :param subscription_id: Azure subscription ID
        :type subscription_id: str
        :param resource_id: ResourceId instance
        :type resource_id: ResourceId
        :return: URL template string
        :rtype: str
        :raises ValueError: If operation is not supported
        """
        if operation == "read":
            return cls._read_url_template
        elif operation == "create":
            return cls._create_url_template
        elif operation == "delete":
            return cls._delete_url_template
        elif operation == "update":
            return cls._update_url_template
        elif operation == "list":
            return cls._list_url_template
        else:
            raise ValueError(f"Unsupported operation '{operation}' for {cls.__name__}")


class BlobContainerAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """Available actions for BlobContainer resources."""
    SET_LEGAL_HOLD = "setLegalHold"
    CLEAR_LEGAL_HOLD = "clearLegalHold"
    LEASE = "lease"
    MIGRATE = "migrate"


class BlobContainer(ResourceType[BlobContainerProperties]):

    """A Blob Container resource."""

    # API version
    api_version = "2025-06-01"

    # Available actions
    ACTIONS = BlobContainerAction

    @classmethod
    def get_available_actions(cls) -> List[str]:
        """Get list of available actions for this resource type.
        
        :return: List of action names
        :rtype: List[str]
        """
        return [action.value for action in cls.ACTIONS]

    @classmethod
    def set_legal_hold_body(cls, tags: List[str]) -> Dict[str, Any]:
        """Create body for setLegalHold action.
        
        :param list[str] tags: Array of tag strings to set on the container
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Example:
            body = BlobContainer.set_legal_hold_body(tags=["tag1", "tag2"])
        """
        # Azure API expects tags as objects with 'tag' property
        tag_objects = [{"tag": tag} for tag in tags]
        return {"tags": tag_objects}

    @classmethod
    def clear_legal_hold_body(cls, tags: List[str]) -> Dict[str, Any]:
        """Create body for clearLegalHold action.
        
        :param list[str] tags: Array of tag strings to clear from the container
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Example:
            body = BlobContainer.clear_legal_hold_body(tags=["tag1"])
        """
        # Azure API expects tags as objects with 'tag' property
        tag_objects = [{"tag": tag} for tag in tags]
        return {"tags": tag_objects}

    @classmethod
    def lease_body(
        cls,
        action: str,
        lease_id: Optional[str] = None,
        break_period: Optional[int] = None,
        lease_duration: Optional[int] = None,
        proposed_lease_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Create body for lease action.
        
        :param str action: Lease action - "Acquire", "Release", "Renew", "Break", or "Change"
        :param str or None lease_id: Required for Release, Renew, Change
        :param int or None break_period: Optional for Break action
        :param int or None lease_duration: Required for Acquire (-1 for infinite, or 15-60 seconds)
        :param str or None proposed_lease_id: Optional for Acquire, required for Change
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Examples:
            # Acquire a 60-second lease
            body = BlobContainer.lease_body(action="Acquire", lease_duration=60)
            
            # Release a lease
            body = BlobContainer.lease_body(action="Release", lease_id="lease-id-here")
        """
        body: Dict[str, Any] = {"action": action}

        if lease_id is not None:
            body["leaseId"] = lease_id
        if break_period is not None:
            body["breakPeriod"] = break_period
        if lease_duration is not None:
            body["leaseDuration"] = lease_duration
        if proposed_lease_id is not None:
            body["proposedLeaseId"] = proposed_lease_id

        return body

    @classmethod
    def migrate_body(cls) -> None:
        """Create body for migrate action (object-level WORM migration).
        
        :return: None (migrate action has no body)
        
        Example:
            body = BlobContainer.migrate_body()  # Returns None
        """
        return None

    @classmethod
    def from_response(cls, data_dict: Dict[str, Any], **kwargs) -> "BlobContainer":
        properties: BlobContainerProperties = data_dict.get("properties", {})  # type: ignore[assignment]

        instance = cls(
            api_version=kwargs.get("api_version", "2025-06-01"),
            properties=properties,
        )

        instance.id = data_dict.get("id")
        instance.name = data_dict.get("name")
        instance.type = data_dict.get("type")

        return instance

    def __init__(
        self,
        *,
        api_version: str = "2025-06-01",
        properties: Optional[BlobContainerProperties] = None,
        **kwargs: Any,
    ) -> None:
        super().__init__(**kwargs)
        self.api_version = api_version
        self.properties = properties


    def to_dict(self) -> Dict[str, Any]:
        """Serialize container for create/update requests.
        
        :return: Serialized dictionary
        :rtype: Dict[str, Any]
        """
        return {
            "properties": self.properties or {},
        }


class StorageAccountResourceId(ResourceId):
    """Resource identity for Storage Account resources.
    
    Encapsulates the identity information required to address a specific
    storage account instance within Azure.
    """
    
    # URL templates for storage account operations
    _read_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{accountName}"
    )

    _create_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{accountName}"
    )

    _delete_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{accountName}"
    )

    _update_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{accountName}"
    )

    _list_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts"
    )
    
    # Action URL templates (POST operations)
    _action_url_templates = {
        "listKeys": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{accountName}/listKeys"
        ),
        "regenerateKey": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{accountName}/regenerateKey"
        ),
        "listAccountSas": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{accountName}/listAccountSas"
        ),
        "listServiceSas": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{accountName}/listServiceSas"
        ),
    }
    
    def __init__(
        self,
        *,
        resource_group_name: str,
        account_name: str,
    ) -> None:
        """Initialize a StorageAccountResourceId.
        
        :param resource_group_name: Name of the resource group
        :type resource_group_name: str
        :param account_name: Name of the storage account
        :type account_name: str
        """
        self.resource_group_name = resource_group_name
        self.account_name = account_name
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to StorageAccountPathParams TypedDict.
        
        :return: PathParams dictionary
        :rtype: Dict[str, Any]
        """
        return {
            "resourceGroupName": self.resource_group_name,
            "accountName": self.account_name,
        }
    
    @classmethod
    def from_dict(cls, params: Dict[str, Any]) -> "StorageAccountResourceId":
        """Create from StorageAccountPathParams TypedDict.
        
        :param params: URL parameters dictionary
        :type params: Dict[str, Any]
        :return: New StorageAccountResourceId instance
        :rtype: StorageAccountResourceId
        """
        return cls(
            resource_group_name=params["resourceGroupName"],
            account_name=params["accountName"],
        )
    
    @classmethod
    def from_resource_id(cls, resource_id: str) -> "StorageAccountResourceId":
        """Parse an ARM resource ID string for a storage account.
        
        Expected format:
        /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}
        
        :param resource_id: Full ARM resource ID string
        :type resource_id: str
        :return: New StorageAccountResourceId instance
        :rtype: StorageAccountResourceId
        :raises ValueError: If the resource ID format is invalid
        """
        pattern = (
            r"^/subscriptions/[^/]+/resourceGroups/(?P<resourceGroupName>[^/]+)/"
            r"providers/Microsoft\.Storage/storageAccounts/(?P<accountName>[^/]+)$"
        )
        
        match = re.match(pattern, resource_id, re.IGNORECASE)
        if not match:
            raise ValueError(
                f"Invalid storage account resource ID format: {resource_id}. "
                f"Expected format: /subscriptions/{{subscriptionId}}/resourceGroups/{{resourceGroupName}}/"
                f"providers/Microsoft.Storage/storageAccounts/{{accountName}}"
            )
        
        return cls(
            resource_group_name=match.group("resourceGroupName"),
            account_name=match.group("accountName"),
        )
    
    def build_path_arguments(self, subscription_id: str) -> Dict[str, Any]:
        """Build path arguments dictionary for URL formatting.
        
        :param subscription_id: Azure subscription ID
        :type subscription_id: str
        :return: Dictionary of path arguments
        :rtype: Dict[str, Any]
        """
        return {
            "subscriptionId": subscription_id,
            "resourceGroupName": self.resource_group_name,
            "accountName": self.account_name,
        }
    
    @classmethod
    def get_operation_url(
        cls,
        operation: str,
        subscription_id: str,
        resource_id: "ResourceId",
    ) -> str:
        """Get the URL template for the given operation.
        
        :param operation: Operation name
        :type operation: str
        :param subscription_id: Azure subscription ID
        :type subscription_id: str
        :param resource_id: ResourceId instance
        :type resource_id: ResourceId
        :return: URL template string
        :rtype: str
        :raises ValueError: If operation is not supported
        """
        if operation == "read":
            return cls._read_url_template
        elif operation == "create":
            return cls._create_url_template
        elif operation == "delete":
            return cls._delete_url_template
        elif operation == "update":
            return cls._update_url_template
        elif operation == "list":
            return cls._list_url_template
        else:
            raise ValueError(f"Unsupported operation '{operation}' for {cls.__name__}")


class StorageAccountAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """Available actions for StorageAccount resources."""
    LIST_KEYS = "listKeys"
    REGENERATE_KEY = "regenerateKey"
    LIST_ACCOUNT_SAS = "listAccountSas"
    LIST_SERVICE_SAS = "listServiceSas"


class StorageAccount(ResourceType[StorageAccountProperties]):
    """A Storage Account resource."""

    # API version
    api_version = "2025-06-01"

    # Available actions
    ACTIONS = StorageAccountAction

    @classmethod
    def get_available_actions(cls) -> List[str]:
        """Get list of available actions for this resource type.
        
        :return: List of action names
        :rtype: List[str]
        """
        return [action.value for action in cls.ACTIONS]

    @classmethod
    def list_keys_body(cls) -> None:
        """Create body for listKeys action.
        
        :return: None (listKeys action has no body)
        
        Example:
            body = StorageAccount.list_keys_body()  # Returns None
        """
        return None

    @classmethod
    def regenerate_key_body(cls, key_name: str) -> Dict[str, Any]:
        """Create body for regenerateKey action.
        
        :param str key_name: The name of the storage account key to regenerate (e.g., "key1", "key2")
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Example:
            body = StorageAccount.regenerate_key_body(key_name="key1")
        """
        return {"keyName": key_name}

    @classmethod
    def list_account_sas_body(
        cls,
        services: str,
        resource_types: str,
        permissions: str,
        expiry: str,
        start: Optional[str] = None,
        ip_address_or_range: Optional[str] = None,
        protocols: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Create body for listAccountSas action.
        
        :param str services: The signed services (Blob, Queue, Table, File). E.g., "bqtf"
        :param str resource_types: The signed resource types (Service, Container, Object). E.g., "sco"
        :param str permissions: The signed permissions (Read, Write, Delete, List, Add, Create, Update, Process). E.g., "rwdlacup"
        :param str expiry: The time at which the SAS becomes invalid (ISO 8601 format)
        :param str or None start: Optional. The time at which the SAS becomes valid (ISO 8601 format)
        :param str or None ip_address_or_range: Optional. IP address or range of addresses. E.g., "168.1.5.60-168.1.5.70"
        :param str or None protocols: Optional. The protocol permitted ("https" or "https,http")
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Example:
            body = StorageAccount.list_account_sas_body(
                services="b",
                resource_types="sco",
                permissions="rl",
                expiry="2026-01-22T00:00:00Z"
            )
        """
        body: Dict[str, Any] = {
            "signedServices": services,
            "signedResourceTypes": resource_types,
            "signedPermission": permissions,
            "signedExpiry": expiry,
        }
        
        if start is not None:
            body["signedStart"] = start
        if ip_address_or_range is not None:
            body["signedIp"] = ip_address_or_range
        if protocols is not None:
            body["signedProtocol"] = protocols
        
        return body

    @classmethod
    def list_service_sas_body(
        cls,
        canonicalized_resource: str,
        permissions: str,
        expiry: str,
        resource: Optional[str] = None,
        start: Optional[str] = None,
        ip_address_or_range: Optional[str] = None,
        protocols: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Create body for listServiceSas action.
        
        :param str canonicalized_resource: The canonical path to the signed resource
        :param str permissions: The signed permissions (Read, Write, Delete, List, Add, Create). E.g., "rwdlac"
        :param str expiry: The time at which the SAS becomes invalid (ISO 8601 format)
        :param str or None resource: Optional. The signed resource type ("b" for blob, "c" for container, "f" for file, "s" for share)
        :param str or None start: Optional. The time at which the SAS becomes valid (ISO 8601 format)
        :param str or None ip_address_or_range: Optional. IP address or range of addresses
        :param str or None protocols: Optional. The protocol permitted ("https" or "https,http")
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Example:
            body = StorageAccount.list_service_sas_body(
                canonicalized_resource="/blob/myaccount/mycontainer",
                permissions="rl",
                expiry="2026-01-22T00:00:00Z",
                resource="c"
            )
        """
        body: Dict[str, Any] = {
            "canonicalizedResource": canonicalized_resource,
            "signedPermission": permissions,
            "signedExpiry": expiry,
        }
        
        if resource is not None:
            body["signedResource"] = resource
        if start is not None:
            body["signedStart"] = start
        if ip_address_or_range is not None:
            body["signedIp"] = ip_address_or_range
        if protocols is not None:
            body["signedProtocol"] = protocols
        
        return body

    @classmethod
    def from_response(cls, data_dict: Dict[str, Any], **kwargs) -> "StorageAccount":
        properties: StorageAccountProperties = data_dict.get("properties", {})  # type: ignore[assignment]

        instance = cls(
            api_version=kwargs.get("api_version", "2025-06-01"),
            sku=data_dict.get("sku"),
            kind=data_dict.get("kind"),
            location=data_dict.get("location"),
            tags=data_dict.get("tags"),
            properties=properties,
        )

        instance.id = data_dict.get("id")
        instance.name = data_dict.get("name")
        instance.type = data_dict.get("type")

        return instance

    def __init__(
        self,
        *,
        api_version: str = "2025-06-01",
        sku: Optional[StorageAccountSku] = None,
        kind: Optional[Union[str, StorageAccountKind]] = None,
        location: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        properties: Optional[StorageAccountProperties] = None,
        **kwargs: Any,
    ) -> None:
        super().__init__(**kwargs)
        self.api_version = api_version
        self.sku = sku
        self.kind = kind
        self.location = location
        self.tags = tags
        self.properties = properties

    def to_dict(self) -> Dict[str, Any]:
        """Serialize storage account for create/update requests.
        
        :return: Serialized dictionary
        :rtype: Dict[str, Any]
        """
        result: Dict[str, Any] = {}
        
        if self.sku is not None:
            result["sku"] = self.sku
        if self.kind is not None:
            result["kind"] = self.kind
        if self.location is not None:
            result["location"] = self.location
        if self.tags is not None:
            result["tags"] = self.tags
        if self.properties is not None:
            result["properties"] = self.properties
        
        return result
