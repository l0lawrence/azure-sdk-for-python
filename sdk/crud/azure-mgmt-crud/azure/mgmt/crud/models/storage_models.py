# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import re
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from typing_extensions import TypedDict, NotRequired
from azure.core import CaseInsensitiveEnumMeta

from .models import ResourceType, ResourceId


class AccountImmutabilityPolicyState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the
    policy, Unlocked state allows increase and decrease of immutability retention time and also
    allows toggling allowProtectedAppendWrites property, Locked state only allows the increase of
    the immutability retention time. A policy can only be created in a Disabled or Unlocked state
    and can be toggled between the two states. Only a policy in an Unlocked state can transition to
    a Locked state which cannot be reverted.
    """

    UNLOCKED = "Unlocked"
    LOCKED = "Locked"
    DISABLED = "Disabled"

class ImmutabilityPolicyProperties(TypedDict):
    """Properties of an Immutability Policy."""
    immutabilityPeriodSinceCreationInDays: Optional[int]
    state: Optional[Union[str,AccountImmutabilityPolicyState]]
    allowProtectedAppendWrites: Optional[bool]

class TagProperty(TypedDict):
    """Tag property of a Legal Hold."""
    tag: Optional[str]
    timestamp: Optional[str]
    objectIdentifier: Optional[str]
    tenantId: Optional[str]
    upn: Optional[str]

class ProtectedAppendWritesHistory(TypedDict):
    """Protected append writes history."""
    allowProtectedAppendWritesAll: Optional[bool]
    timestamp: Optional[str]

class LegalHoldProperties(TypedDict):
    """Properties of a Legal Hold."""
    hasLegalHold: Optional[bool]
    tags: Optional[List[TagProperty]]
    protectedAppendWritesHistory: Optional[ProtectedAppendWritesHistory]

class MigrationState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """This property denotes the container level immutability to object level immutability migration
    state.
    """

    IN_PROGRESS = "InProgress"
    COMPLETED = "Completed"

class ImmutableStorageWithVersioning(TypedDict):
    """Immutable storage with versioning properties."""
    enabled: Optional[bool]
    timeStamp: Optional[str]
    migrationState: Optional[Union[str, MigrationState]]


class BlobContainerProperties(TypedDict):
    """Properties of a Blob Container resource."""
    publicAccess: NotRequired[Optional[str]]
    lastModifiedTime: NotRequired[Optional[str]]
    etag: NotRequired[Optional[str]]
    version: NotRequired[Optional[str]]
    deleted: NotRequired[Optional[bool]]
    deletedTime: NotRequired[Optional[str]]
    remainingRetentionDays: NotRequired[Optional[int]]
    defaultEncryptionScope: NotRequired[Optional[str]]
    denyEncryptionScopeOverride: NotRequired[Optional[bool]]
    leaseStatus: NotRequired[Optional[str]]
    leaseState: NotRequired[Optional[str]]
    leaseDuration: NotRequired[Optional[str]]
    metadata: NotRequired[Optional[Dict[str, str]]]
    immutabilityPolicy: NotRequired[Optional[ImmutabilityPolicyProperties]]
    legalHold: NotRequired[Optional[LegalHoldProperties]]
    hasLegalHold: NotRequired[Optional[bool]]
    hasImmutabilityPolicy: NotRequired[Optional[bool]]
    immutableStorageWithVersioning: NotRequired[Optional[ImmutableStorageWithVersioning]]
    enableNfsV3RootSquash: NotRequired[Optional[bool]]
    enableNfsV3AllSquash: NotRequired[Optional[bool]]


class BlobContainerPathParams(TypedDict):
    """URL parameters required to address a blob container."""

    resourceGroupName: str
    storageAccountName: str
    containerName: str


class BlobContainerResourceId(ResourceId):
    """Resource identity for Blob Container resources.
    
    Encapsulates the identity information required to address a specific
    blob container instance within Azure Storage.
    """
    
    # URL templates for blob container operations
    _read_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    _create_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    _delete_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    _update_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers/{containerName}"
    )

    _list_url_template = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
        "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
        "blobServices/default/containers"
    )
    
    # Action URL templates (POST operations)
    _action_url_templates = {
        "setLegalHold": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
            "blobServices/default/containers/{containerName}/setLegalHold"
        ),
        "clearLegalHold": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
            "blobServices/default/containers/{containerName}/clearLegalHold"
        ),
        "lease": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
            "blobServices/default/containers/{containerName}/lease"
        ),
        "migrate": (
            "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/"
            "providers/Microsoft.Storage/storageAccounts/{storageAccountName}/"
            "blobServices/default/containers/{containerName}/migrate"
        ),
    }
    
    def __init__(
        self,
        *,
        resource_group_name: str,
        storage_account_name: str,
        container_name: str,
    ) -> None:
        """Initialize a BlobContainerResourceId.
        
        :param resource_group_name: Name of the resource group
        :type resource_group_name: str
        :param storage_account_name: Name of the storage account
        :type storage_account_name: str
        :param container_name: Name of the container
        :type container_name: str
        """
        self.resource_group_name = resource_group_name
        self.storage_account_name = storage_account_name
        self.container_name = container_name
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to BlobContainerPathParams TypedDict.
        
        :return: PathParams dictionary
        :rtype: Dict[str, Any]
        """
        return {
            "resourceGroupName": self.resource_group_name,
            "storageAccountName": self.storage_account_name,
            "containerName": self.container_name,
        }
    
    @classmethod
    def from_dict(cls, params: Dict[str, Any]) -> "BlobContainerResourceId":
        """Create from BlobContainerPathParams TypedDict.
        
        :param params: URL parameters dictionary
        :type params: Dict[str, Any]
        :return: New BlobContainerResourceId instance
        :rtype: BlobContainerResourceId
        """
        return cls(
            resource_group_name=params["resourceGroupName"],
            storage_account_name=params["storageAccountName"],
            container_name=params["containerName"],
        )
    
    @classmethod
    def from_resource_id(cls, resource_id: str) -> "BlobContainerResourceId":
        """Parse an ARM resource ID string for a blob container.
        
        Expected format:
        /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}
        
        :param resource_id: Full ARM resource ID string
        :type resource_id: str
        :return: New BlobContainerResourceId instance
        :rtype: BlobContainerResourceId
        :raises ValueError: If the resource ID format is invalid
        """
        pattern = (
            r"^/subscriptions/[^/]+/resourceGroups/(?P<resourceGroupName>[^/]+)/"
            r"providers/Microsoft\.Storage/storageAccounts/(?P<storageAccountName>[^/]+)/"
            r"blobServices/default/containers/(?P<containerName>[^/]+)$"
        )
        
        match = re.match(pattern, resource_id, re.IGNORECASE)
        if not match:
            raise ValueError(
                f"Invalid blob container resource ID format: {resource_id}. "
                f"Expected format: /subscriptions/{{subscriptionId}}/resourceGroups/{{resourceGroupName}}/"
                f"providers/Microsoft.Storage/storageAccounts/{{accountName}}/blobServices/default/"
                f"containers/{{containerName}}"
            )
        
        return cls(
            resource_group_name=match.group("resourceGroupName"),
            storage_account_name=match.group("storageAccountName"),
            container_name=match.group("containerName"),
        )
    
    def build_path_arguments(self, subscription_id: str) -> Dict[str, Any]:
        """Build path arguments dictionary for URL formatting.
        
        :param subscription_id: Azure subscription ID
        :type subscription_id: str
        :return: Dictionary of path arguments
        :rtype: Dict[str, Any]
        """
        return {
            "subscriptionId": subscription_id,
            "resourceGroupName": self.resource_group_name,
            "storageAccountName": self.storage_account_name,
            "containerName": self.container_name,
        }
    
    @classmethod
    def get_operation_url(
        cls,
        operation: str,
        subscription_id: str,
        resource_id: "ResourceId",
    ) -> str:
        """Get the URL template for the given operation.
        
        :param operation: Operation name
        :type operation: str
        :param subscription_id: Azure subscription ID
        :type subscription_id: str
        :param resource_id: ResourceId instance
        :type resource_id: ResourceId
        :return: URL template string
        :rtype: str
        :raises ValueError: If operation is not supported
        """
        if operation == "read":
            return cls._read_url_template
        elif operation == "create":
            return cls._create_url_template
        elif operation == "delete":
            return cls._delete_url_template
        elif operation == "update":
            return cls._update_url_template
        elif operation == "list":
            return cls._list_url_template
        else:
            raise ValueError(f"Unsupported operation '{operation}' for {cls.__name__}")


class BlobContainerAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
    """Available actions for BlobContainer resources."""
    SET_LEGAL_HOLD = "setLegalHold"
    CLEAR_LEGAL_HOLD = "clearLegalHold"
    LEASE = "lease"
    MIGRATE = "migrate"


class BlobContainer(ResourceType[BlobContainerProperties]):

    """A Blob Container resource."""

    # API version
    api_version = "2025-06-01"

    # Available actions
    ACTIONS = BlobContainerAction

    @classmethod
    def get_available_actions(cls) -> List[str]:
        """Get list of available actions for this resource type.
        
        :return: List of action names
        :rtype: List[str]
        """
        return [action.value for action in cls.ACTIONS]

    @classmethod
    def set_legal_hold_body(cls, tags: List[str]) -> Dict[str, Any]:
        """Create body for setLegalHold action.
        
        :param list[str] tags: Array of tag strings to set on the container
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Example:
            body = BlobContainer.set_legal_hold_body(tags=["tag1", "tag2"])
        """
        # Azure API expects tags as objects with 'tag' property
        tag_objects = [{"tag": tag} for tag in tags]
        return {"tags": tag_objects}

    @classmethod
    def clear_legal_hold_body(cls, tags: List[str]) -> Dict[str, Any]:
        """Create body for clearLegalHold action.
        
        :param list[str] tags: Array of tag strings to clear from the container
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Example:
            body = BlobContainer.clear_legal_hold_body(tags=["tag1"])
        """
        # Azure API expects tags as objects with 'tag' property
        tag_objects = [{"tag": tag} for tag in tags]
        return {"tags": tag_objects}

    @classmethod
    def lease_body(
        cls,
        action: str,
        lease_id: Optional[str] = None,
        break_period: Optional[int] = None,
        lease_duration: Optional[int] = None,
        proposed_lease_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Create body for lease action.
        
        :param str action: Lease action - "Acquire", "Release", "Renew", "Break", or "Change"
        :param str or None lease_id: Required for Release, Renew, Change
        :param int or None break_period: Optional for Break action
        :param int or None lease_duration: Required for Acquire (-1 for infinite, or 15-60 seconds)
        :param str or None proposed_lease_id: Optional for Acquire, required for Change
        :return: Request body dictionary
        :rtype: Dict[str, Any]
        
        Examples:
            # Acquire a 60-second lease
            body = BlobContainer.lease_body(action="Acquire", lease_duration=60)
            
            # Release a lease
            body = BlobContainer.lease_body(action="Release", lease_id="lease-id-here")
        """
        body: Dict[str, Any] = {"action": action}

        if lease_id is not None:
            body["leaseId"] = lease_id
        if break_period is not None:
            body["breakPeriod"] = break_period
        if lease_duration is not None:
            body["leaseDuration"] = lease_duration
        if proposed_lease_id is not None:
            body["proposedLeaseId"] = proposed_lease_id

        return body

    @classmethod
    def migrate_body(cls) -> None:
        """Create body for migrate action (object-level WORM migration).
        
        :return: None (migrate action has no body)
        
        Example:
            body = BlobContainer.migrate_body()  # Returns None
        """
        return None

    @classmethod
    def from_response(cls, data_dict: Dict[str, Any], **kwargs) -> "BlobContainer":
        properties: BlobContainerProperties = data_dict.get("properties", {})  # type: ignore[assignment]

        instance = cls(
            api_version=kwargs.get("api_version", "2025-06-01"),
            properties=properties,
        )

        instance.id = data_dict.get("id")
        instance.name = data_dict.get("name")
        instance.type = data_dict.get("type")

        return instance

    def __init__(
        self,
        *,
        api_version: str = "2025-06-01",
        properties: Optional[BlobContainerProperties] = None,
        **kwargs: Any,
    ) -> None:
        super().__init__(**kwargs)
        self.api_version = api_version
        self.properties = properties


    def to_dict(self) -> Dict[str, Any]:
        """Serialize container for create/update requests.
        
        :return: Serialized dictionary
        :rtype: Dict[str, Any]
        """
        return {
            "properties": self.properties or {},
        }
